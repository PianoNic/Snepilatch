name: Build and Release Flutter Apps

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  build-android:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '17'

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.35.x'
          channel: 'stable'
          cache: true

      - name: Setup release keystore
        working-directory: ./snepilatch/android/app
        env:
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
        run: |
          echo "Setting up release keystore from secrets..."
          if [ -n "$KEYSTORE_BASE64" ]; then
            echo "Using existing keystore from secrets"
            echo "$KEYSTORE_BASE64" | base64 -d > app-release.jks
          else
            echo "Generating new keystore (consider storing it as KEYSTORE_BASE64 secret)"
            keytool -genkey -v -keystore app-release.jks -keyalg RSA -keysize 2048 -validity 10000 -alias snepilatch \
              -dname "CN=Snepilatch App, OU=Development, O=Snepilatch, L=Ruebliland, S=Aargau, C=CH" \
              -storepass "$KEYSTORE_PASSWORD" -keypass "$KEY_PASSWORD" -noprompt
          fi

      - name: Create key.properties
        working-directory: ./snepilatch/android
        env:
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
        run: |
          echo "Creating key.properties file..."
          cat > key.properties << EOF
          storePassword=$KEYSTORE_PASSWORD
          keyPassword=$KEY_PASSWORD
          keyAlias=snepilatch
          storeFile=app-release.jks
          EOF

      - name: Get dependencies
        working-directory: ./snepilatch
        run: flutter pub get

      - name: Generate app icons
        working-directory: ./snepilatch
        run: dart run flutter_launcher_icons -f flutter_launcher_icons-prod.yaml

      - name: Build Android APK
        working-directory: ./snepilatch
        env:
          SENTRY_DSN: ${{ vars.SENTRY_URL }}
        run: |
          flutter build apk --release \
            --flavor prod \
            --build-name="${{ github.ref_name }}" \
            --build-number="${{ github.run_number }}" \
            --dart-define=SENTRY_DSN="$SENTRY_DSN" \
            --dart-define=SENTRY_RELEASE="${{ github.ref_name }}" \
            --dart-define=SENTRY_ENVIRONMENT="production"

      - name: Prepare artifacts
        working-directory: ./snepilatch
        run: |
          mkdir -p artifacts
          cp build/app/outputs/flutter-apk/app-prod-release.apk artifacts/snepilatch-${{ github.ref_name }}.apk

      - name: Upload Android artifacts
        uses: actions/upload-artifact@v4
        with:
          name: android-build
          path: snepilatch/artifacts/

  upload-to-release:
    needs: [build-android]
    runs-on: ubuntu-latest
    if: github.event_name == 'release'
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Upload Assets to Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            android-build/snepilatch-${{ github.ref_name }}.apk
          append_body: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Send Discord Notification
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          RELEASE_TAG: ${{ github.ref_name }}
          RELEASE_BODY: ${{ github.event.release.body }}
          RELEASE_URL: ${{ github.event.release.html_url }}
        run: |
          # Parse release body to extract sections
          RELEASE_BODY_ESCAPED=$(echo "$RELEASE_BODY" | jq -Rs .)

          # Create Discord message
          cat > discord_payload.json << 'EOF'
          {
            "content": "@everyone\n\nðŸ“± **New Release - $RELEASE_TAG!**\nA new update is now available!\n\n**What's New:**\n$CHANGES\n\n**Download the latest version:** [$RELEASE_TAG]($RELEASE_URL)\n\nThanks for your support and feedback! ðŸŽµâœ¨"
          }
          EOF

          # Process the release body to format it nicely
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          import re

          release_body = os.environ.get('RELEASE_BODY', '')
          release_tag = os.environ.get('RELEASE_TAG', '')
          release_url = os.environ.get('RELEASE_URL', '')

          # Extract sections from release body
          changes = []
          current_section = None

          for line in release_body.split('\n'):
              line = line.strip()
              if not line:
                  continue

              # Detect section headers
              if line.startswith('## '):
                  continue
              elif line.startswith('ðŸš€ Features') or line.startswith('**ðŸš€ Features**'):
                  current_section = 'ðŸš€ Features'
                  changes.append('')
                  changes.append('ðŸš€ **Features**')
              elif line.startswith('âœ¨ Enhancements') or line.startswith('**âœ¨ Enhancements**'):
                  current_section = 'âœ¨ Enhancements'
                  changes.append('')
                  changes.append('âœ¨ **Enhancements**')
              elif line.startswith('ðŸ› ï¸ Refactors') or line.startswith('**ðŸ› ï¸ Refactors**'):
                  current_section = 'ðŸ› ï¸ Refactors'
                  changes.append('')
                  changes.append('ðŸ› ï¸ **Refactors**')
              elif line.startswith('ðŸ› Bug Fixes') or line.startswith('**ðŸ› Bug Fixes**'):
                  current_section = 'ðŸ› Bug Fixes'
                  changes.append('')
                  changes.append('ðŸ› **Bug Fixes**')
              elif line.startswith('- ') and current_section:
                  changes.append(line)
              elif line.startswith('**Full Changelog'):
                  break

          # Build the message content
          changes_text = '\n'.join(changes) if changes else 'See release notes for details.'

          message = f"ðŸ“± **New Release - {release_tag}!**\nA new update is now available!\n\n**What's New:**{changes_text}\n\n**Download the latest version:** [{release_tag}]({release_url})\n\nThanks for your support and feedback! ðŸŽµâœ¨\n\n||@everyone||"

          payload = {
              "content": message
          }

          with open('discord_payload.json', 'w') as f:
              json.dump(payload, f)
          PYTHON_SCRIPT

          # Send to Discord
          curl -H "Content-Type: application/json" \
               -d @discord_payload.json \
               "$DISCORD_WEBHOOK_URL"